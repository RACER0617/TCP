# TCP Calculator with Epoll/WSAPoll

## Домашнее задание

1. **TCP сервер** — калькулятор, который принимает на вход числовые арифметические выражения и возвращает результат вычисления. Выражения разделяются пробелами между операндами и операторами; внутри каждого операнда или оператора пробелов быть не должно.
2. **TCP клиент** — верификатор работы сервера. Клиент генерирует случайное арифметическое выражение, состоящее из *n* чисел (параметр `n`). Получившаяся строка дробится на случайное количество фрагментов (по 1–10 байт) и каждый фрагмент отправляется по TCP. После отправки всех фрагментов клиент ожидает ответа от сервера и сравнивает полученный результат с локальным. Если ответы не совпадают, клиент выводит в `std::cerr` исходное выражение, ответ сервера и корректный результат.

**Требования:**

* Сервер конфигурируется одним аргументом: *порт*.
* Клиент конфигурируется четырьмя аргументами:

    * `n` — количество чисел в выражении,
    * `connections` — число параллельных TCP-сессий,
    * `server_addr` — адрес сервера,
    * `server_port` — порт сервера.
* Использование epoll (Linux) или WSAPoll (Windows) в обоих приложениях обязательно.

---

## Описание программы

* **Сервер (**\`\`**)**

    * Создаёт слушающий сокет на указанном порту.
    * С помощью epoll ждёт новых соединений и данных от клиентов.
    * Для каждого соединения читает **полное** выражение (накапливая данные до EOF), вычисляет результат и отправляет обратно, затем закрывает соединение.
    * Логи работы (приём данных, вычисление, отправка) выводит в `stdout`.

* **Клиент (**\`\`**)**

    * При старте принимает параметры `n`, `connections`, `server_addr`, `server_port`.
    * Запускает `connections` потоков, каждый из которых:

        1. Генерирует выражение из `n` случайных чисел и операторов (`+ - * /`), без пробелов внутри.
        2. Локально вычисляет ожидаемый результат.
        3. Дробит строку на случайные фрагменты (1–10 байт) и отправляет их по TCP.
        4. Выполняет `shutdown(SHUT_WR)` для завершения передачи и ждёт ответа.
        5. При получении ответа сравнивает его с локальным результатом:

            * Если `|ответ − ожидаемый| < 1e-6`, выводит в `stdout` сообщение о корректности.
            * Иначе — выводит в `std::cerr` выражение, ответ и правильный результат.

---

## Сборка и запуск (Linux)

### Зависимости

* CMake ≥ 3.10
* Компилятор с поддержкой C++17 (g++, clang++)

### Сборка

```bash
# Перейти в корень проекта
cd /path/to/project

# Создать и перейти в каталог для сборки
mkdir -p build && cd build

# Сгенерировать файлы сборки
cmake ..

# Собрать сервер и клиента
cmake --build .
```

В результате в каталоге `build` появятся исполняемые файлы:

* `calc_server`
* `calc_client`

### Запуск

1. **Сервер**. Откройте терминал в `build` и выполните:

   ```bash
   ./calc_server <port>
   ```

   Например:

   ```bash
   ./calc_server 5555
   ```

2. **Клиент**. В другом терминале (тогда как сервер запущен) выполните:

   ```bash
   ./calc_client <n> <connections> <server_addr> <server_port>
   ```

   Пример:

   ```bash
   ./calc_client 5 3 127.0.0.1 5555
   ```

    * `5` — количество чисел в выражении.
    * `3` — число параллельных соединений.
    * `127.0.0.1` — адрес сервера.
    * `5555` — порт сервера.

### Пример вывода

```
$ ./calc_server 5555
Starting server on port 5555...
Listening socket created (fd=3)
Epoll instance created. Waiting for connections...

#...при подключениях и вычислениях...
```

```
$ ./calc_client 5 3 127.0.0.1 5555
Client: n=5, sessions=3, server=127.0.0.1:5555
----------------------------------------
[THREAD 12345] Expr="10/32+73+16*39" (expected=3483.19)
[THREAD 12345] Sent chunk 1 (5 bytes): '10/32'
...
[THREAD 12345] Received: 3483.19
[THREAD 12345] ✔ OK
```

---

*Конец README.md*
